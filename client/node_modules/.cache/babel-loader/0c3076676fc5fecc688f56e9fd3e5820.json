{"ast":null,"code":"import React, { useState, useEffect } from 'react';\n\nvar WheelComponent = function WheelComponent(_ref) {\n  var segments = _ref.segments,\n      segColors = _ref.segColors,\n      winningSegment = _ref.winningSegment,\n      onFinished = _ref.onFinished,\n      primaryColor = _ref.primaryColor,\n      contrastColor = _ref.contrastColor,\n      buttonText = _ref.buttonText;\n  var currentSegment = '';\n  var isStarted = false;\n\n  var _useState = useState(false),\n      isFinished = _useState[0],\n      setFinished = _useState[1];\n\n  var timerHandle = 0;\n  var timerDelay = segments.length;\n  var angleCurrent = 0;\n  var angleDelta = 0;\n  var size = 290;\n  var canvasContext = null;\n  var maxSpeed = Math.PI / (\"\" + segments.length);\n  var upTime = segments.length * 100;\n  var downTime = segments.length * 1000;\n  var spinStart = 0;\n  var frames = 0;\n  var centerX = 300;\n  var centerY = 300;\n  useEffect(function () {\n    wheelInit();\n    setTimeout(function () {\n      window.scrollTo(0, 1);\n    }, 0);\n  }, []);\n\n  var wheelInit = function wheelInit() {\n    initCanvas();\n    wheelDraw();\n  };\n\n  var initCanvas = function initCanvas() {\n    var canvas = document.getElementById('canvas');\n\n    if (navigator.appVersion.indexOf('MSIE') !== -1) {\n      canvas = document.createElement('canvas');\n      canvas.setAttribute('width', 1000);\n      canvas.setAttribute('height', 600);\n      canvas.setAttribute('id', 'canvas');\n      document.getElementById('wheel').appendChild(canvas);\n    }\n\n    canvas.addEventListener('click', spin, false);\n    canvasContext = canvas.getContext('2d');\n  };\n\n  var spin = function spin() {\n    isStarted = true;\n\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime();\n      maxSpeed = Math.PI / segments.length;\n      frames = 0;\n      timerHandle = setInterval(onTimerTick, timerDelay);\n    }\n  };\n\n  var onTimerTick = function onTimerTick() {\n    frames++;\n    draw();\n    var duration = new Date().getTime() - spinStart;\n    var progress = 0;\n    var finished = false;\n\n    if (duration < upTime) {\n      progress = duration / upTime;\n      angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2);\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n          progress = 1;\n        } else {\n          progress = duration / downTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n        }\n      } else {\n        progress = duration / downTime;\n        angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n      }\n\n      if (progress >= 1) finished = true;\n    }\n\n    angleCurrent += angleDelta;\n\n    while (angleCurrent >= Math.PI * 2) {\n      angleCurrent -= Math.PI * 2;\n    }\n\n    if (finished) {\n      setFinished(true);\n      onFinished(currentSegment);\n      clearInterval(timerHandle);\n      timerHandle = 0;\n      angleDelta = 0;\n    }\n  };\n\n  var wheelDraw = function wheelDraw() {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n\n  var draw = function draw() {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n\n  var drawSegment = function drawSegment(key, lastAngle, angle) {\n    var ctx = canvasContext;\n    var value = segments[key];\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY);\n    ctx.arc(centerX, centerY, size, lastAngle, angle, false);\n    ctx.lineTo(centerX, centerY);\n    ctx.closePath();\n    ctx.fillStyle = segColors[key];\n    ctx.fill();\n    ctx.stroke();\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    ctx.rotate((lastAngle + angle) / 2);\n    ctx.fillStyle = contrastColor || 'white';\n    ctx.font = 'bold 1em proxima-nova';\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0);\n    ctx.restore();\n  };\n\n  var drawWheel = function drawWheel() {\n    var ctx = canvasContext;\n    var lastAngle = angleCurrent;\n    var len = segments.length;\n    var PI2 = Math.PI * 2;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = primaryColor || 'black';\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = 'center';\n    ctx.font = '1em proxima-nova';\n\n    for (var i = 1; i <= len; i++) {\n      var angle = PI2 * (i / len) + angleCurrent;\n      drawSegment(i - 1, lastAngle, angle);\n      lastAngle = angle;\n    }\n\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 50, 0, PI2, false);\n    ctx.closePath();\n    ctx.fillStyle = primaryColor || 'black';\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = contrastColor || 'white';\n    ctx.fill();\n    ctx.font = 'bold 1em proxima-nova';\n    ctx.fillStyle = contrastColor || 'white';\n    ctx.textAlign = 'center';\n    ctx.fillText(buttonText || 'Spin', centerX, centerY + 3);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, size, 0, PI2, false);\n    ctx.closePath();\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = primaryColor || 'black';\n    ctx.stroke();\n  };\n\n  var drawNeedle = function drawNeedle() {\n    var ctx = canvasContext;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = contrastColor || 'white';\n    ctx.fileStyle = contrastColor || 'white';\n    ctx.beginPath();\n    ctx.moveTo(centerX + 20, centerY - 50);\n    ctx.lineTo(centerX - 20, centerY - 50);\n    ctx.lineTo(centerX, centerY - 70);\n    ctx.closePath();\n    ctx.fill();\n    var change = angleCurrent + Math.PI / 2;\n    var i = segments.length - Math.floor(change / (Math.PI * 2) * segments.length) - 1;\n    if (i < 0) i = i + segments.length;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillStyle = primaryColor || 'black';\n    ctx.font = 'bold 1.5em proxima-nova';\n    currentSegment = segments[i];\n    isStarted && ctx.fillText(currentSegment, centerX + 10, centerY + size + 50);\n  };\n\n  var clear = function clear() {\n    var ctx = canvasContext;\n    ctx.clearRect(0, 0, 1000, 800);\n  };\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    id: \"wheel\"\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    id: \"canvas\",\n    width: \"1000\",\n    height: \"800\",\n    style: {\n      pointerEvents: isFinished ? 'none' : 'auto'\n    }\n  }));\n};\n\nexport default WheelComponent;","map":{"version":3,"sources":["../src/index.js"],"names":["WheelComponent","segments","segColors","winningSegment","onFinished","primaryColor","contrastColor","buttonText","currentSegment","isStarted","isFinished","setFinished","useState","timerHandle","timerDelay","angleCurrent","angleDelta","size","canvasContext","maxSpeed","Math","upTime","downTime","spinStart","frames","centerX","centerY","useEffect","wheelInit","setTimeout","window","initCanvas","wheelDraw","canvas","document","navigator","spin","setInterval","onTimerTick","draw","duration","progress","finished","clearInterval","clear","drawWheel","drawNeedle","drawSegment","ctx","value","lastAngle","len","PI2","i","angle","change","pointerEvents"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from 'react'\n\n const WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  primaryColor,\n  contrastColor,\n  buttonText\n}) => {\n  let currentSegment = ''\n  let isStarted = false\n  const [isFinished, setFinished] = useState(false)\n  let timerHandle = 0\n  const timerDelay = segments.length\n  let angleCurrent = 0\n  let angleDelta = 0\n  const size = 290\n  let canvasContext = null\n  let maxSpeed = Math.PI / `${segments.length}`\n  const upTime = segments.length * 100\n  const downTime = segments.length * 1000\n  let spinStart = 0\n  let frames = 0\n  const centerX = 300\n  const centerY = 300\n  useEffect(() => {\n    wheelInit()\n    setTimeout(() => {\n      window.scrollTo(0, 1)\n    }, 0)\n  }, [])\n  const wheelInit = () => {\n    initCanvas()\n    wheelDraw()\n  }\n\n  const initCanvas = () => {\n    let canvas = document.getElementById('canvas')\n    if (navigator.appVersion.indexOf('MSIE') !== -1) {\n      canvas = document.createElement('canvas')\n      canvas.setAttribute('width', 1000)\n      canvas.setAttribute('height', 600)\n      canvas.setAttribute('id', 'canvas')\n      document.getElementById('wheel').appendChild(canvas)\n    }\n    canvas.addEventListener('click', spin, false)\n    canvasContext = canvas.getContext('2d')\n  }\n  const spin = () => {\n    isStarted = true\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime()\n      // maxSpeed = Math.PI / ((segments.length*2) + Math.random())\n      maxSpeed = Math.PI / segments.length\n      frames = 0\n      timerHandle = setInterval(onTimerTick, timerDelay)\n    }\n  }\n  const onTimerTick = () => {\n    frames++\n    draw()\n    const duration = new Date().getTime() - spinStart\n    let progress = 0\n    let finished = false\n    if (duration < upTime) {\n      progress = duration / upTime\n      angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2)\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2)\n          progress = 1\n        } else {\n          progress = duration / downTime\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2)\n        }\n      } else {\n        progress = duration / downTime\n        angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2)\n      }\n      if (progress >= 1) finished = true\n    }\n\n    angleCurrent += angleDelta\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2\n    if (finished) {\n      setFinished(true)\n      onFinished(currentSegment)\n      clearInterval(timerHandle)\n      timerHandle = 0\n      angleDelta = 0\n    }\n  }\n\n  const wheelDraw = () => {\n    clear()\n    drawWheel()\n    drawNeedle()\n  }\n\n  const draw = () => {\n    clear()\n    drawWheel()\n    drawNeedle()\n  }\n\n  const drawSegment = (key, lastAngle, angle) => {\n    const ctx = canvasContext\n    const value = segments[key]\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(centerX, centerY)\n    ctx.arc(centerX, centerY, size, lastAngle, angle, false)\n    ctx.lineTo(centerX, centerY)\n    ctx.closePath()\n    ctx.fillStyle = segColors[key]\n    ctx.fill()\n    ctx.stroke()\n    ctx.save()\n    ctx.translate(centerX, centerY)\n    ctx.rotate((lastAngle + angle) / 2)\n    ctx.fillStyle = contrastColor || 'white'\n    ctx.font = 'bold 1em proxima-nova'\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0)\n    ctx.restore()\n  }\n\n  const drawWheel = () => {\n    const ctx = canvasContext\n    let lastAngle = angleCurrent\n    const len = segments.length\n    const PI2 = Math.PI * 2\n    ctx.lineWidth = 1\n    ctx.strokeStyle = primaryColor || 'black'\n    ctx.textBaseline = 'middle'\n    ctx.textAlign = 'center'\n    ctx.font = '1em proxima-nova'\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent\n      drawSegment(i - 1, lastAngle, angle)\n      lastAngle = angle\n    }\n\n    // Draw a center circle\n    ctx.beginPath()\n    ctx.arc(centerX, centerY, 50, 0, PI2, false)\n    ctx.closePath()\n    ctx.fillStyle = primaryColor || 'black'\n    ctx.lineWidth = 10\n    ctx.strokeStyle = contrastColor || 'white'\n    ctx.fill()\n    ctx.font = 'bold 1em proxima-nova'\n    ctx.fillStyle = contrastColor || 'white'\n    ctx.textAlign = 'center'\n    ctx.fillText(buttonText || 'Spin', centerX, centerY + 3)\n    ctx.stroke()\n\n    // Draw outer circle\n    ctx.beginPath()\n    ctx.arc(centerX, centerY, size, 0, PI2, false)\n    ctx.closePath()\n\n    ctx.lineWidth = 10\n    ctx.strokeStyle = primaryColor || 'black'\n    ctx.stroke()\n  }\n\n  const drawNeedle = () => {\n    const ctx = canvasContext\n    ctx.lineWidth = 1\n    ctx.strokeStyle = contrastColor || 'white'\n    ctx.fileStyle = contrastColor || 'white'\n    ctx.beginPath()\n    ctx.moveTo(centerX + 20, centerY - 50)\n    ctx.lineTo(centerX - 20, centerY - 50)\n    ctx.lineTo(centerX, centerY - 70)\n    ctx.closePath()\n    ctx.fill()\n    const change = angleCurrent + Math.PI / 2\n    let i =\n      segments.length -\n      Math.floor((change / (Math.PI * 2)) * segments.length) -\n      1\n    if (i < 0) i = i + segments.length\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.fillStyle = primaryColor || 'black'\n    ctx.font = 'bold 1.5em proxima-nova'\n    currentSegment = segments[i]\n    isStarted && ctx.fillText(currentSegment, centerX + 10, centerY + size + 50)\n  }\n  const clear = () => {\n    const ctx = canvasContext\n    ctx.clearRect(0, 0, 1000, 800)\n  }\n  return (\n    <div id='wheel'>\n      <canvas\n        id='canvas'\n        width='1000'\n        height='800'\n        style={{\n          pointerEvents: isFinished ? 'none' : 'auto'\n        }}\n      />\n    </div>\n  )\n}\nexport default WheelComponent\n"]},"metadata":{},"sourceType":"module"}